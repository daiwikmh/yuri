// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";
import {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";
import {Hooks} from "v4-core/libraries/Hooks.sol";
import {PoolKey} from "v4-core/types/PoolKey.sol";
import {SwapParams} from "v4-core/types/PoolOperation.sol";
import {ModifyLiquidityParams} from "v4-core/types/PoolOperation.sol";
import {BalanceDelta} from "v4-core/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/types/BeforeSwapDelta.sol";
import {Currency} from "v4-core/types/Currency.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {StateLibrary} from "v4-core/libraries/StateLibrary.sol";
import {PoolId} from "v4-core/types/PoolId.sol";
import {CurrencyLibrary} from "v4-core/types/Currency.sol";
import "./ILeverageInterfaces.sol";

/**
 * @title InstantLeverageHook
 * @notice Hook for instant leverage trading through temporary pool liquidity
 * @dev Enables users to get leveraged positions without collateral via atomic trades
 */

    
contract InstantLeverageHook is BaseHook, Ownable {
    using StateLibrary for IPoolManager;
    using SafeERC20 for IERC20;
    using CurrencyLibrary for Currency;

    // ============ Constants ============
    
    uint256 public constant MAX_LEVERAGE_MULTIPLIER = 10; // 10x max
    uint24 public constant DYNAMIC_FEE_FLAG = 0x800000;
    uint256 public constant POOL_FEE_BPS = 300; // 3% fee to pool on profits
    uint256 public constant USER_PROFIT_BPS = 9700; // 97% to user on profits

    // ============ State Variables ============

    address public immutable walletFactory;     // Your WalletFactory contract
    mapping(bytes32 => PoolInfo) public poolInfo;
    mapping(address => bool) public authorizedPlatforms;
    mapping(bytes32 => InstantLeverageRequest) public pendingRequests;
    mapping(bytes32 => LeveragePosition) public leveragePositions; // requestId -> position
    mapping(address => bytes32[]) public userPositions; // user -> position IDs

    // Track pool debts for each position
    mapping(bytes32 => PoolDebt) public poolDebts; // requestId -> debt info
    // Track TokenC holdings per position (hook custody)
    mapping(bytes32 => uint256) public targetTokenHoldings; // requestId -> TokenC amount held by hook

    // ============ Structs ============

    struct InstantLeverageRequest {
        address user;                // User's EOA
        address userWallet;          // User's smart wallet address
        address tokenIn;             // Base token user is spending (TokenA)
        address tokenOut;            // Intermediate token (TokenB)
        address targetToken;         // Final token user wants exposure to (TokenC)
        uint256 userBaseAmount;      // Amount from user's wallet
        uint256 leverageMultiplier;  // 1-10x leverage
        uint256 minOutputAmount;     // Slippage protection
        bytes32 delegationHash;      // Delegation signature hash
        bytes32 requestId;           // Unique request identifier
    }

    struct LeveragePosition {
        address user;
        address userWallet;
        address tokenIn;             // Base token (TokenA)
        address tokenOut;            // Intermediate token (TokenB)
        address targetToken;         // Target token (TokenC) - held by hook
        uint256 initialNotional;     // Total position size (user + leverage)
        uint256 userContribution;    // User's base amount
        uint256 leverageAmount;      // Amount borrowed from pool (in TokenA)
        uint256 leverageMultiplier;
        uint256 openPrice;           // TokenB/TokenC price at position open
        uint256 liquidationThreshold; // Position value at which to liquidate
        uint256 openTimestamp;
        uint256 targetTokenAmount;   // Actual TokenC held by hook for user
        uint256 intermediateAmount;  // TokenB amount from first swap
        bool isOpen;
    }

    struct PoolDebt {
        bytes32 poolId;              // Which pool the debt is owed to
        address debtToken;           // Token that must be repaid (tokenIn)
        address repayToken;          // Token to repay in (tokenOut)
        uint256 debtAmount;          // Amount owed to pool in debtToken
        uint256 repayAmountRequired; // Amount needed in repayToken to settle debt
        bool isSettled;              // Whether debt has been repaid
    }

    struct PoolInfo {
        uint256 totalLent;           // Total currently lent out
        uint256 maxLendingLimit;     // Maximum amount pool will lend
        uint256 utilizationRate;     // Current utilization percentage
        bool isActive;               // Whether pool accepts leverage requests
    }

    // ============ Events ============

    event LeveragePositionOpened(
        bytes32 indexed requestId,
        address indexed user,
        address userWallet,
        address tokenIn,          // TokenA
        address tokenOut,         // TokenB
        address targetToken,      // TokenC
        uint256 userAmount,
        uint256 leverageAmount,
        uint256 totalNotional,
        uint256 targetTokenAmount // TokenC amount held by hook
    );

    event LeveragePositionClosed(
        bytes32 indexed requestId,
        address indexed user,
        uint256 finalValue,
        int256 pnl,
        uint256 userProceeds,
        uint256 poolFee,
        string reason
    );

    event PositionLiquidated(
        bytes32 indexed requestId,
        address indexed user,
        uint256 liquidationValue,
        uint256 poolRepayment
    );

    event PoolUtilizationUpdated(
        bytes32 indexed poolId,
        uint256 utilizationRate,
        uint256 newFee
    );

    event LeverageRequestFailed(
        bytes32 indexed requestId,
        string reason
    );

    // ============ Modifiers ============

    modifier onlyAuthorizedPlatform() {
        require(authorizedPlatforms[msg.sender], "Unauthorized platform");
        _;
    }

    // ============ Constructor ============

    constructor(
        IPoolManager _poolManager,
        address _walletFactory
    ) BaseHook(_poolManager) Ownable(msg.sender) {
        walletFactory = _walletFactory;
        authorizedPlatforms[_walletFactory] = true;
    }

    // ============ Hook Permissions ============

    function getHookPermissions()
        public
        pure
        override
        returns (Hooks.Permissions memory)
    {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: true,    // Setup pool info
            beforeAddLiquidity: false,
            beforeRemoveLiquidity: true,  // Handle instant leverage
            afterAddLiquidity: false,
            afterRemoveLiquidity: true,   // Cleanup and fee updates
            beforeSwap: true,             // Validate leverage trades
            afterSwap: true,              // Track pool state
            beforeDonate: false,
            afterDonate: false,
            beforeSwapReturnDelta: false,
            afterSwapReturnDelta: false,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    // ============ Hook Implementation ============

    /**
     * @notice Initialize pool for leverage trading
     */
    function _afterInitialize(
        address sender,
        PoolKey calldata key,
        uint160 sqrtPriceX96,
        int24 tick
    ) internal override returns (bytes4) {
        bytes32 poolId = _getPoolId(key);

        // Initialize pool with default leverage settings
        poolInfo[poolId] = PoolInfo({
            totalLent: 0,
            maxLendingLimit: 1000000 ether, // Default 1M limit
            utilizationRate: 0,
            isActive: true
        });

        return BaseHook.afterInitialize.selector;
    }

    /**
     * @notice Handle instant leverage requests
     * @dev Called when platform requests temporary liquidity for user leverage
     */
    function _beforeRemoveLiquidity(
        address sender,
        PoolKey calldata key,
        ModifyLiquidityParams calldata params,
        bytes calldata hookData
    ) internal override returns (bytes4) {

        // Only process if called by authorized platform with leverage request
        if (hookData.length > 0 && authorizedPlatforms[sender]) {
            InstantLeverageRequest memory request = abi.decode(hookData, (InstantLeverageRequest));

            // Validate leverage request
            require(_validateLeverageRequest(key, request), "Invalid leverage request");

            // Execute instant leverage logic
            _executeInstantLeverage(key, request, params);
        }

        return BaseHook.beforeRemoveLiquidity.selector;
    }

    /**
     * @notice Complete leverage operation and update pool state
     */
    function _afterRemoveLiquidity(
        address sender,
        PoolKey calldata key,
        ModifyLiquidityParams calldata params,
        BalanceDelta delta,
        BalanceDelta feesAccrued,
        bytes calldata hookData
    ) internal override returns (bytes4, BalanceDelta) {

        if (hookData.length > 0 && authorizedPlatforms[sender]) {
            bytes32 poolId = _getPoolId(key);

            // Update pool utilization after leverage operation
            _updatePoolUtilization(poolId, key);

            // Calculate and apply dynamic fees based on new utilization
            _updateDynamicFees(poolId, key);
        }

        return (BaseHook.afterRemoveLiquidity.selector, BalanceDelta.wrap(0));
    }

    /**
     * @notice Validate swaps during leverage operations
     */
    function _beforeSwap(
        address sender,
        PoolKey calldata key,
        SwapParams calldata params,
        bytes calldata hookData
    ) internal override returns (bytes4, BeforeSwapDelta, uint24) {

        bytes32 poolId = _getPoolId(key);
        PoolInfo memory pool = poolInfo[poolId];

        // Ensure pool is active and not over-utilized
        require(pool.isActive, "Pool not active for leverage");
        require(pool.utilizationRate < 9000, "Pool over-utilized"); // Max 90%

        return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);
    }

    /**
     * @notice Track pool state after swaps
     */
    function _afterSwap(
        address sender,
        PoolKey calldata key,
        SwapParams calldata params,
        BalanceDelta delta,
        bytes calldata hookData
    ) internal override returns (bytes4, int128) {

        // Update pool metrics for risk management
        bytes32 poolId = _getPoolId(key);
        _trackPoolHealth(poolId, key, delta);

        return (BaseHook.afterSwap.selector, 0);
    }

    // ============ Internal Functions ============

    /**
     * @notice Validate leverage request parameters
     */
    function _validateLeverageRequest(
        PoolKey calldata key,
        InstantLeverageRequest memory request
    ) internal view returns (bool) {
        
        // Check leverage multiplier
        if (request.leverageMultiplier == 0 || request.leverageMultiplier > MAX_LEVERAGE_MULTIPLIER) {
            return false;
        }
        
        // Check user has base funds (this would integrate with UserWallet contract)
        if (request.userBaseAmount == 0) {
            return false;
        }
        
        // Check pool can provide leverage amount
        bytes32 poolId = _getPoolId(key);
        PoolInfo memory pool = poolInfo[poolId];
        uint256 leverageAmount = request.userBaseAmount * (request.leverageMultiplier - 1);
        
        if (leverageAmount > (pool.maxLendingLimit - pool.totalLent)) {
            return false;
        }
        
        return true;
    }

    /**
     * @notice Execute instant leverage trade atomically
     */
    function _executeInstantLeverage(
        PoolKey calldata key,
        InstantLeverageRequest memory request,
        ModifyLiquidityParams calldata params
    ) internal {
        
        try this._performLeverageTrade(key, request) returns (uint256 targetTokenAmount, uint256 openPrice) {

            // Calculate position details
            uint256 leverageAmount = request.userBaseAmount * (request.leverageMultiplier - 1);
            uint256 totalNotional = request.userBaseAmount * request.leverageMultiplier;
            uint256 liquidationThreshold = totalNotional / request.leverageMultiplier; // 1/leverage rule

            // Create leverage position
            LeveragePosition memory position = LeveragePosition({
                user: request.user,
                userWallet: request.userWallet,
                tokenIn: request.tokenIn,            // TokenA
                tokenOut: request.tokenOut,          // TokenB
                targetToken: request.targetToken,    // TokenC
                initialNotional: totalNotional,
                userContribution: request.userBaseAmount,
                leverageAmount: leverageAmount,      // Amount borrowed from TokenA/TokenB pool
                leverageMultiplier: request.leverageMultiplier,
                openPrice: openPrice,                // TokenB/TokenC price
                liquidationThreshold: liquidationThreshold,
                openTimestamp: block.timestamp,
                targetTokenAmount: targetTokenAmount, // TokenC amount held by hook
                intermediateAmount: 0,               // Will be set if needed for tracking
                isOpen: true
            });

            // Store position
            leveragePositions[request.requestId] = position;
            userPositions[request.user].push(request.requestId);

            // DO NOT credit user wallet - hook holds TokenC for user
            // User only sees their position through the leveragePosition mapping
            
            emit LeveragePositionOpened(
                request.requestId,
                request.user,
                request.userWallet,
                request.tokenIn,         // TokenA
                request.tokenOut,        // TokenB
                request.targetToken,     // TokenC
                request.userBaseAmount,
                leverageAmount,
                totalNotional,
                targetTokenAmount        // TokenC amount held by hook
            );
            
        } catch Error(string memory reason) {
            emit LeverageRequestFailed(request.requestId, reason);
        }
    }

    /**
     * @notice Close leverage position and handle profit/loss distribution
     * @param requestId Position to close
     * @param currentPrice Current market price
     */
    function closeLeveragePosition(
        bytes32 requestId,
        uint256 currentPrice // TokenB/TokenC price for calculating TokenC value
    ) external returns (bool success) {

        LeveragePosition storage position = leveragePositions[requestId];
        require(position.isOpen, "Position not open");
        require(msg.sender == position.user || authorizedPlatforms[msg.sender], "Unauthorized");

        PoolDebt storage debt = poolDebts[requestId];
        require(!debt.isSettled, "Debt already settled");

        // Mark position as closed
        position.isOpen = false;

        // STEP 1: Convert TokenC back to TokenB for pool repayment
        uint256 tokenCAmount = targetTokenHoldings[requestId];
        require(tokenCAmount > 0, "No TokenC to close");

        // Create TokenB/TokenC pool key for the swap
        PoolKey memory targetPoolKey = PoolKey({
            currency0: position.targetToken < position.tokenOut ? Currency.wrap(position.targetToken) : Currency.wrap(position.tokenOut),
            currency1: position.targetToken < position.tokenOut ? Currency.wrap(position.tokenOut) : Currency.wrap(position.targetToken),
            fee: 3000,
            tickSpacing: 60,
            hooks: this
        });

        // Swap TokenC -> TokenB
        uint256 tokenBReceived = _executeSwap(
            targetPoolKey,
            position.targetToken, // TokenC
            position.tokenOut,    // TokenB
            tokenCAmount
        );

        // Clear TokenC holdings
        targetTokenHoldings[requestId] = 0;

        // STEP 2: Repay pool debt (requires TokenA, so we may need another swap)
        _repayPoolDebtCrossToken(requestId, position, debt, tokenBReceived);

        // STEP 3: Distribute any remaining TokenB to user
        _distributeRemainingFunds(requestId, position, tokenBReceived);

        emit LeveragePositionClosed(
            requestId,
            position.user,
            tokenBReceived,  // finalValue
            0,               // pnl (calculated elsewhere)
            tokenBReceived,  // userProceeds (remaining after debt repayment)
            0,               // poolFee
            "Cross-pool position closed"
        );
        return true;
    }

    /**
     * @notice Repay pool debt for cross-token scenarios (TokenB -> TokenA)
     * @dev Converts TokenB to TokenA to repay the leverage pool debt
     */
    function _repayPoolDebtCrossToken(
        bytes32 requestId,
        LeveragePosition memory position,
        PoolDebt storage debt,
        uint256 tokenBAmount
    ) internal {
        // Create TokenA/TokenB pool key for swap back to TokenA
        PoolKey memory leveragePoolKey = PoolKey({
            currency0: position.tokenIn < position.tokenOut ? Currency.wrap(position.tokenIn) : Currency.wrap(position.tokenOut),
            currency1: position.tokenIn < position.tokenOut ? Currency.wrap(position.tokenOut) : Currency.wrap(position.tokenIn),
            fee: 3000,
            tickSpacing: 60,
            hooks: this
        });

        // Calculate how much TokenB we need to swap to get enough TokenA for debt repayment
        uint256 tokenANeeded = debt.debtAmount;
        uint256 tokenBForDebt;

        // Check if we have enough TokenB to cover the debt conversion
        if (tokenBAmount >= tokenANeeded) {
            // Use amount needed for debt
            tokenBForDebt = tokenANeeded; // Simplified 1:1 conversion for demo
        } else {
            // Use all available TokenB
            tokenBForDebt = tokenBAmount;
        }

        // Swap TokenB -> TokenA for pool repayment
        uint256 tokenAReceived = _executeSwap(
            leveragePoolKey,
            position.tokenOut, // TokenB
            position.tokenIn,  // TokenA
            tokenBForDebt
        );

        // Repay the pool directly with TokenA
        _repayPoolDirect(debt.poolId, position.tokenIn, tokenAReceived);

        // Mark debt as settled
        debt.isSettled = true;

        // Update pool state
        bytes32 poolId = _getPoolId(leveragePoolKey);
        poolInfo[poolId].totalLent -= debt.debtAmount;
    }

    /**
     * @notice Distribute remaining funds to user after pool repayment
     * @dev Sends any remaining TokenB to user's wallet
     */
    function _distributeRemainingFunds(
        bytes32 requestId,
        LeveragePosition memory position,
        uint256 tokenBAmount
    ) internal {
        // After debt repayment, check what's left
        PoolDebt memory debt = poolDebts[requestId];

        // Calculate value used for debt repayment (simplified)
        uint256 usedForDebt = debt.debtAmount; // In practice, use actual swap amounts

        if (tokenBAmount > usedForDebt) {
            uint256 userPortion = tokenBAmount - usedForDebt;

            // Credit user's wallet with remaining TokenB
            IUserWallet(position.userWallet).creditBalance(position.tokenOut, userPortion);
        }
        // Note: Event emission happens in main close function
    }

    /**
     * @notice Repay pool debt from position's tokenOut holdings
     * @dev This MUST be called first before any profit distribution
     */
    function _repayPoolDebt(
        bytes32 requestId,
        LeveragePosition memory position,
        PoolDebt storage debt,
        uint256 currentPrice
    ) internal {
        // Calculate exact repayment needed in tokenOut
        uint256 repayAmountInTokenOut = (debt.debtAmount * 1e18) / currentPrice;

        // Ensure we have enough tokenOut to repay (position.targetTokenAmount)
        require(position.targetTokenAmount >= repayAmountInTokenOut, "Insufficient funds to repay pool");

        // Convert tokenOut back to tokenIn to repay pool
        if (debt.repayToken != debt.debtToken) {
            // Execute reverse swap: tokenOut -> tokenIn
            _repayPoolViaSwap(debt.poolId, debt.repayToken, debt.debtToken, repayAmountInTokenOut, debt.debtAmount);
        } else {
            // Direct repayment in same token
            _repayPoolDirect(debt.poolId, debt.debtToken, debt.debtAmount);
        }

        // Update pool state
        bytes32 poolId = _getPoolId(PoolKey({
            currency0: Currency.wrap(debt.debtToken),
            currency1: Currency.wrap(debt.repayToken),
            fee: 3000,
            tickSpacing: 60,
            hooks: this
        }));
        poolInfo[poolId].totalLent -= debt.debtAmount;

        // Mark debt as settled
        debt.isSettled = true;
    }

    /**
     * @notice Repay pool via swap (tokenOut -> tokenIn)
     */
    function _repayPoolViaSwap(
        bytes32 poolId,
        address tokenOut,
        address tokenIn,
        uint256 amountOut,
        uint256 minAmountIn
    ) internal {
        // Execute swap to convert tokenOut back to tokenIn for pool repayment
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(tokenIn),
            currency1: Currency.wrap(tokenOut),
            fee: 3000,
            tickSpacing: 60,
            hooks: this
        });

        SwapParams memory swapParams = SwapParams({
            zeroForOne: tokenOut < tokenIn,
            amountSpecified: int256(amountOut), // Exact output
            sqrtPriceLimitX96: 0
        });

        poolManager.swap(key, swapParams, "");

        // Settle the repayment with pool
        poolManager.settle();
    }

    /**
     * @notice Repay pool directly in same token
     */
    function _repayPoolDirect(bytes32 poolId, address token, uint256 amount) internal {
        // Transfer tokens back to pool
        IERC20(token).safeTransfer(address(poolManager), amount);

        // Settle with pool manager
        poolManager.settle();
    }

    /**
     * @notice Handle profitable position closure
     */
    function _handleProfitableClose(
        bytes32 requestId,
        LeveragePosition memory position,
        uint256 currentValue,
        uint256 profit
    ) internal {
        // Calculate remaining amount after pool repayment
        PoolDebt memory debt = poolDebts[requestId];
        uint256 repayAmount = (debt.debtAmount * 1e18) / position.openPrice;
        uint256 remainingAmount = position.targetTokenAmount - repayAmount;

        // Distribute profits: pool fee from profit, rest to user
        uint256 poolFee = (profit * POOL_FEE_BPS) / 10000;
        uint256 userProceeds = remainingAmount - poolFee;

        // Send pool fee to pool
        IERC20(position.tokenOut).safeTransfer(address(poolManager), poolFee);

        // Credit remaining amount to user wallet
        IUserWallet(position.userWallet).creditBalance(position.tokenOut, userProceeds);

        emit LeveragePositionClosed(requestId, position.user, currentValue, int256(profit), userProceeds, poolFee, "Profitable close");
    }

    /**
     * @notice Handle loss position closure
     */
    function _handleLossClose(
        bytes32 requestId,
        LeveragePosition memory position,
        uint256 currentValue,
        uint256 loss
    ) internal {
        // After pool debt repayment, calculate remaining user funds
        PoolDebt memory debt = poolDebts[requestId];
        uint256 repayAmount = (debt.debtAmount * 1e18) / _getPoolPrice(PoolKey({
            currency0: Currency.wrap(debt.debtToken),
            currency1: Currency.wrap(debt.repayToken),
            fee: 3000,
            tickSpacing: 60,
            hooks: this
        }));

        // User gets whatever remains after pool repayment (could be zero)
        uint256 userRemainder = position.targetTokenAmount > repayAmount ? position.targetTokenAmount - repayAmount : 0;

        if (userRemainder > 0) {
            IUserWallet(position.userWallet).creditBalance(position.tokenOut, userRemainder);
        }

        emit LeveragePositionClosed(requestId, position.user, currentValue, -int256(loss), userRemainder, 0, "Loss close");
    }

    /**
     * @notice Check and execute liquidation if needed
     * @param requestId Position to check
     * @param currentPrice Current market price
     */
    function checkLiquidation(
        bytes32 requestId,
        uint256 currentPrice
    ) external returns (bool liquidated) {

        LeveragePosition storage position = leveragePositions[requestId];
        require(position.isOpen, "Position not open");

        uint256 currentValue = _calculatePositionValue(position, currentPrice);

        // Liquidation rule: if position value falls below 1/leverage of initial notional
        if (currentValue <= position.liquidationThreshold) {

            // Mark as closed
            position.isOpen = false;

            // STEP 1: Repay pool debt first (pool has priority in liquidation)
            _repayPoolDebt(requestId);

            // STEP 2: Any remaining value goes to liquidation penalties/protocol
            // User gets nothing on liquidation (position value too low)

            emit PositionLiquidated(
                requestId,
                position.user,
                currentValue,
                0 // User receives nothing in liquidation
            );

            return true;
        }

        return false;
    }

    /**
     * @notice Calculate current position value using pool price
     */
    function _calculatePositionValue(
        LeveragePosition memory position,
        uint256 currentPrice
    ) internal pure returns (uint256) {

        if (currentPrice == 0 || position.openPrice == 0) {
            return 0;
        }

        // For cross-pool leverage: calculate value based on actual TokenC amount held
        // Value = targetTokenAmount * (currentPrice / openPrice)
        return (position.targetTokenAmount * currentPrice) / position.openPrice;
    }

    /**
     * @notice Get current price from Uniswap V4 pool (external)
     */
    function getPoolPrice(PoolKey calldata key) external view returns (uint256) {
        return _getPoolPrice(key);
    }

    /**
     * @notice Get current price from Uniswap V4 pool (internal)
     */
    function _getPoolPrice(PoolKey memory key) internal view returns (uint256) {
        PoolId poolId = PoolId.wrap(_getPoolId(key));

        // Get pool slot0 data using StateLibrary
        (uint160 sqrtPriceX96,,,) = poolManager.getSlot0(poolId);

        // Convert sqrtPriceX96 to regular price
        uint256 price = _sqrtPriceX96ToPrice(sqrtPriceX96);

        return price;
    }

    /**
     * @notice Convert sqrtPriceX96 to regular price (simplified)
     */
    function _sqrtPriceX96ToPrice(uint160 sqrtPriceX96) internal pure returns (uint256) {
        if (sqrtPriceX96 == 0) return 0;
        return (uint256(sqrtPriceX96) * uint256(sqrtPriceX96) * 1e18) >> 192;
    }

    /**
     * @notice Get current position health
     * @param requestId Position ID
     * @param currentPrice Current market price
     */
    function getPositionHealth(
        bytes32 requestId,
        uint256 currentPrice
    ) external view returns (
        uint256 currentValue,
        uint256 liquidationThreshold,
        bool isHealthy,
        int256 pnl
    ) {
        LeveragePosition memory position = leveragePositions[requestId];
        require(position.isOpen, "Position not open");
        
        currentValue = _calculatePositionValue(position, currentPrice);
        liquidationThreshold = position.liquidationThreshold;
        isHealthy = currentValue > liquidationThreshold;
        pnl = int256(currentValue) - int256(position.initialNotional);
        
        return (currentValue, liquidationThreshold, isHealthy, pnl);
    }

    /**
     * @notice Perform the actual leverage trade with real pool funds
     */
    function _performLeverageTrade(
        PoolKey calldata leveragePoolKey, // TokenA/TokenB pool for leverage
        InstantLeverageRequest memory request
    ) external returns (uint256 targetTokenAmount, uint256 openPrice) {
        require(msg.sender == address(this), "Internal only");

        // Validate the request would work
        require(_validateLeverageRequest(leveragePoolKey, request), "Leverage validation failed");

        // Calculate leverage amounts
        uint256 leverageAmount = request.userBaseAmount * (request.leverageMultiplier - 1);
        uint256 totalTradeAmount = request.userBaseAmount + leverageAmount;

        bytes32 leveragePoolId = _getPoolId(leveragePoolKey);

        // STEP 1: Withdraw user's base amount (TokenA) from their wallet
        _withdrawUserFunds(request.userWallet, request.tokenIn, request.userBaseAmount);

        // STEP 2: Temporarily withdraw leverage amount (TokenA) from TokenA/TokenB pool
        _withdrawFromPool(leveragePoolKey, Currency.wrap(request.tokenIn), leverageAmount);

        // STEP 3: First swap - TokenA -> TokenB using leverage pool
        uint256 tokenBAmount = _executeSwap(
            leveragePoolKey,
            request.tokenIn,
            request.tokenOut,
            totalTradeAmount
        );

        // STEP 4: Second swap - TokenB -> TokenC using target pool
        PoolKey memory targetPoolKey = PoolKey({
            currency0: request.tokenOut < request.targetToken ? Currency.wrap(request.tokenOut) : Currency.wrap(request.targetToken),
            currency1: request.tokenOut < request.targetToken ? Currency.wrap(request.targetToken) : Currency.wrap(request.tokenOut),
            fee: 3000,
            tickSpacing: 60,
            hooks: this
        });

        // Get opening price from target pool (TokenB/TokenC)
        openPrice = _getPoolPrice(targetPoolKey);
        require(openPrice > 0, "Invalid target pool price");

        // Execute second swap: TokenB -> TokenC
        targetTokenAmount = _executeSwap(
            targetPoolKey,
            request.tokenOut,    // TokenB
            request.targetToken, // TokenC
            tokenBAmount
        );

        // Apply slippage protection
        require(targetTokenAmount >= request.minOutputAmount, "Slippage exceeded");

        // STEP 5: Hook holds TokenC for user (user never gets direct access)
        targetTokenHoldings[request.requestId] = targetTokenAmount;

        // STEP 6: Track the pool debt that must be repaid on closure (in TokenA)
        _createPoolDebt(request.requestId, leveragePoolId, request.tokenIn, request.tokenOut, leverageAmount, openPrice);

        // Update pool lending state
        poolInfo[leveragePoolId].totalLent += leverageAmount;

        return (targetTokenAmount, openPrice);
    }

    /**
     * @notice Withdraw user's base funds from their wallet
     * @dev This ensures user funds are actually used, not just tracked
     */
    function _withdrawUserFunds(address userWallet, address token, uint256 amount) internal {
        // UserWallet must transfer tokens to this contract for the trade
        IUserWallet(userWallet).executeTrade(
            token,
            amount,
            abi.encodeWithSelector(this._receiveUserFunds.selector, token, amount),
            bytes32(0) // Empty delegation hash - this should be handled at controller level
        );
    }

    /**
     * @notice Receive user funds (called by UserWallet)
     */
    function _receiveUserFunds(address token, uint256 amount) external {
        // Verify the transfer was successful
        if (token == address(0)) {
            require(msg.value == amount, "ETH amount mismatch");
        } else {
            require(IERC20(token).balanceOf(address(this)) >= amount, "Token transfer failed");
        }
    }

    /**
     * @notice Withdraw leverage amount from pool liquidity
     * @dev This temporarily removes liquidity from the pool
     */
    function _withdrawFromPool(PoolKey memory key, Currency currency, uint256 amount) internal {
        // Use poolManager.sync to sync the token
        poolManager.sync(currency);

        // Use poolManager.take to withdraw tokens from pool
        poolManager.take(currency, address(this), amount);
    }

    /**
     * @notice Execute swap using pool manager
     * @dev Swaps the combined amount (user + leverage) for tokenOut
     */
    function _executeSwap(
        PoolKey memory key,
        address tokenIn,
        address tokenOut,
        uint256 amountIn
    ) internal returns (uint256 amountOut) {
        // Prepare swap parameters
        SwapParams memory swapParams = SwapParams({
            zeroForOne: tokenIn < tokenOut, // Determine swap direction
            amountSpecified: -int256(amountIn), // Negative = exact input
            sqrtPriceLimitX96: 0 // No price limit
        });

        // Execute swap through pool manager
        BalanceDelta delta = poolManager.swap(key, swapParams, "");

        // Extract amount out from delta
        amountOut = uint256(int256(swapParams.zeroForOne ? delta.amount1() : delta.amount0()));

        return amountOut;
    }

    /**
     * @notice Create pool debt record for position
     * @dev Tracks exactly how much must be repaid to the pool
     */
    function _createPoolDebt(
        bytes32 requestId,
        bytes32 poolId,
        address debtToken,
        address repayToken,
        uint256 debtAmount,
        uint256 openPrice
    ) internal {
        // Calculate required repayment amount in tokenOut based on current price
        uint256 repayAmountRequired = (debtAmount * 1e18) / openPrice;

        poolDebts[requestId] = PoolDebt({
            poolId: poolId,
            debtToken: debtToken,
            repayToken: repayToken,
            debtAmount: debtAmount,
            repayAmountRequired: repayAmountRequired,
            isSettled: false
        });
    }

    /**
     * @notice Get user's open positions
     */
    function getUserPositions(address user) external view returns (bytes32[] memory) {
        return userPositions[user];
    }

    /**
     * @notice Interface for UserWallet credit balance
     */
    

    /**
     * @notice Update pool utilization rate
     */
    function _updatePoolUtilization(bytes32 poolId, PoolKey calldata key) internal {
        // Simplified utilization tracking
        PoolInfo storage pool = poolInfo[poolId];
        // Basic utilization calculation - can be enhanced later
        if (pool.maxLendingLimit > 0) {
            pool.utilizationRate = (pool.totalLent * 10000) / pool.maxLendingLimit;
        }
    }

    /**
     * @notice Update dynamic fees based on utilization
     */
    function _updateDynamicFees(bytes32 poolId, PoolKey calldata key) internal {
        PoolInfo memory pool = poolInfo[poolId];
        uint24 newFee = pool.utilizationRate > 8000 ? 3000 : 500; // Simple fee logic
        if (key.fee == DYNAMIC_FEE_FLAG) {
            emit PoolUtilizationUpdated(poolId, pool.utilizationRate, newFee);
        }
    }

    /**
     * @notice Track pool health metrics
     */
    function _trackPoolHealth(bytes32 poolId, PoolKey calldata key, BalanceDelta delta) internal {
        // Simplified health tracking
    }

    /**
     * @notice Generate pool ID from pool key
     */
    function _getPoolId(PoolKey memory key) internal pure returns (bytes32) {
        return keccak256(abi.encode(key.currency0, key.currency1, key.fee, key.tickSpacing));
    }

    // ============ Admin Functions ============

    /**
     * @notice Authorize new platform contract
     */
    function authorizePlatform(address platform) external onlyOwner {
        authorizedPlatforms[platform] = true;
    }
}